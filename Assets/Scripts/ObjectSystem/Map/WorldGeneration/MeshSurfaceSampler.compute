#pragma kernel SampleMeshSurface

struct TriangleData
{
    float3 v0; float _padding0;
    float3 v1; float _padding1;
    float3 v2; float _padding2;
    float3 n0; float _padding3;
    float3 n1; float _padding4;
    float3 n2; float _padding5;
};

struct InstanceData
{
    float4x4 trs;
    float4 color;
};

StructuredBuffer<TriangleData> triangles;
RWStructuredBuffer<InstanceData> instanceData;

int instanceCount;
int triangleCount;
float3 scaleMin;
float3 scaleMax;
float density;
bool alignToNormal;
bool randomYRotation;
float maxYRotation;
int randomSeed;

uint Hash(uint s)
{
    s = (s ^ 61u) ^ (s >> 16u);
    s *= 9u;
    s = s ^ (s >> 4u);
    s *= 0x27d4eb2du;
    s = s ^ (s >> 15u);
    return s;
}

float Random(uint seed)
{
    return float(Hash(seed)) / 4294967295.0;
}

float3 RandomPointInTriangle(float3 v0, float3 v1, float3 v2, uint seed)
{
    float r1 = Random(seed);
    float r2 = Random(seed + 1);
    
    float sqrtR1 = sqrt(r1);
    float u = 1.0 - sqrtR1;
    float v = r2 * sqrtR1;
    
    return v0 * u + v1 * v + v2 * (1.0 - u - v);
}

float3 InterpolateNormal(float3 n0, float3 n1, float3 n2, float3 bary)
{
    return normalize(n0 * bary.x + n1 * bary.y + n2 * bary.z);
}

float3 GetBarycentricCoords(float3 p, float3 v0, float3 v1, float3 v2)
{
    float3 v0v1 = v1 - v0;
    float3 v0v2 = v2 - v0;
    float3 v0p = p - v0;
    
    float d00 = dot(v0v1, v0v1);
    float d01 = dot(v0v1, v0v2);
    float d11 = dot(v0v2, v0v2);
    float d20 = dot(v0p, v0v1);
    float d21 = dot(v0p, v0v2);
    
    float denom = d00 * d11 - d01 * d01;
    float v = (d11 * d20 - d01 * d21) / denom;
    float w = (d00 * d21 - d01 * d20) / denom;
    float u = 1.0 - v - w;
    
    return float3(u, v, w);
}

float4 QuaternionFromToRotation(float3 from, float3 to)
{
    float3 cross_vec = cross(from, to);
    float dot_val = dot(from, to);
    
    if (dot_val < -0.999999)
    {
        float3 axis = abs(from.x) < abs(from.y) ? float3(1, 0, 0) : float3(0, 1, 0);
        axis = normalize(cross(from, axis));
        return float4(axis, 0);
    }
    
    float s = sqrt((1.0 + dot_val) * 2.0);
    float invS = 1.0 / s;
    
    return float4(cross_vec * invS, s * 0.5);
}

float4 QuaternionAxisAngle(float3 axis, float angle)
{
    float halfAngle = angle * 0.5;
    float s = sin(halfAngle);
    return float4(axis * s, cos(halfAngle));
}

float4 QuaternionMultiply(float4 q1, float4 q2)
{
    return float4(
        q1.w * q2.xyz + q2.w * q1.xyz + cross(q1.xyz, q2.xyz),
        q1.w * q2.w - dot(q1.xyz, q2.xyz)
    );
}

float3x3 QuaternionToMatrix(float4 q)
{
    float3x3 m;
    
    float x = q.x, y = q.y, z = q.z, w = q.w;
    float x2 = x + x, y2 = y + y, z2 = z + z;
    float xx = x * x2, xy = x * y2, xz = x * z2;
    float yy = y * y2, yz = y * z2, zz = z * z2;
    float wx = w * x2, wy = w * y2, wz = w * z2;
    
    m[0][0] = 1.0 - (yy + zz);
    m[0][1] = xy + wz;
    m[0][2] = xz - wy;
    
    m[1][0] = xy - wz;
    m[1][1] = 1.0 - (xx + zz);
    m[1][2] = yz + wx;
    
    m[2][0] = xz + wy;
    m[2][1] = yz - wx;
    m[2][2] = 1.0 - (xx + yy);
    
    return m;
}

float4x4 TRS(float3 position, float4 rotation, float3 scale)
{
    float3x3 rotMatrix = QuaternionToMatrix(rotation);
    
    float4x4 mat;
    mat[0] = float4(rotMatrix[0] * scale.x, 0);
    mat[1] = float4(rotMatrix[1] * scale.y, 0);
    mat[2] = float4(rotMatrix[2] * scale.z, 0);
    mat[3] = float4(position, 1);
    
    return mat;
}

float3 GetGrassColor(uint seed, float3 position)
{
    float colorVar = Random(seed) * 0.4 + 0.8;
    
    float noise = sin(position.x * 0.5) * sin(position.z * 0.5);
    colorVar += noise * 0.2;
    
    float dryness = saturate((position.y - 10.0) / 20.0);
    float3 greenTint = float3(0.9, 1.0, 0.9);
    float3 dryTint = float3(1.0, 0.95, 0.8);
    
    return lerp(greenTint, dryTint, dryness) * colorVar;
}

[numthreads(64, 1, 1)]
void SampleMeshSurface(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint)instanceCount)
        return;
    
    uint seed = id.x * 73856093u + randomSeed;
    
    uint triangleIndex = uint(Random(seed) * float(triangleCount - 1));
    TriangleData tri = triangles[triangleIndex];
    
    float3 position = RandomPointInTriangle(tri.v0, tri.v1, tri.v2, seed + 1);
    float3 bary = GetBarycentricCoords(position, tri.v0, tri.v1, tri.v2);
    float3 normal = InterpolateNormal(tri.n0, tri.n1, tri.n2, bary);
    
    float3 scale = lerp(scaleMin, scaleMax, float3(
        Random(seed + 2),
        Random(seed + 3),
        Random(seed + 4)
    ));
    
    float4 rotation = float4(0, 0, 0, 1);
    
    if (alignToNormal)
    {
        rotation = QuaternionFromToRotation(float3(0, 1, 0), normal);
    }
    
    if (randomYRotation)
    {
        float yAngle = (Random(seed + 5) * 2.0 - 1.0) * maxYRotation * 0.0174533;
        float4 yRot = QuaternionAxisAngle(float3(0, 1, 0), yAngle);
        rotation = QuaternionMultiply(rotation, yRot);
    }
    
    instanceData[id.x].trs = TRS(position, rotation, scale);
    
    float colorVariation = Random(seed + 6) * 0.3 + 0.7;
    // instanceData[id.x].color = float4(GetGrassColor(seed, position), 1);
    instanceData[id.x].color = float4(1, 1, 1, 1);
}