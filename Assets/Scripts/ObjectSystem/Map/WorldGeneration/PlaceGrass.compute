#pragma kernel PlaceGrass

struct InstanceData
{
    float4x4 trs;
    float4 color;
};

RWStructuredBuffer<InstanceData> instanceData;
StructuredBuffer<float> heightMap;

int terrainResolution;
int instanceCount;
int gridMinX;
int gridMinZ;
int gridWidth;
int gridHeight;
int bladesPerCell;
float density;
float scaleMin;
float scaleMax;
float rotationVariation;
float3 worldBoundsMin;
float3 worldBoundsMax;
float terrainWidth;
float terrainHeight;
float noiseScale;
float densityMinThreshold;
float densityMaxThreshold;
int octaves;
float persistence;
float lacunarity;

float scaleNoiseScale;
float scaleNoiseInfluence;
int scaleOctaves;
float scalePersistence;
float scaleLacunarity;

uint Hash(uint input)
{
    uint state = input * 747796405u + 2891336453u;
    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
    return (word >> 22u) ^ word;
}

uint Hash2D(uint x, uint y)
{
    return Hash(x ^ Hash(y));
}

uint Hash3D(uint x, uint y, uint z)
{
    return Hash(x ^ Hash(y ^ Hash(z)));
}

float HashToFloat(uint hash)
{
    return (hash & 0xFFFFFF) / 16777216.0;
}

float PerlinNoise(float2 pos)
{
    int2 i = floor(pos);
    float2 f = frac(pos);
    
    f = f * f * (3.0 - 2.0 * f);
    
    uint hash00 = Hash2D((uint)i.x, (uint)i.y);
    uint hash10 = Hash2D((uint)i.x + 1, (uint)i.y);
    uint hash01 = Hash2D((uint)i.x, (uint)i.y + 1);
    uint hash11 = Hash2D((uint)i.x + 1, (uint)i.y + 1);
    
    float v00 = HashToFloat(hash00);
    float v10 = HashToFloat(hash10);
    float v01 = HashToFloat(hash01);
    float v11 = HashToFloat(hash11);
    
    float x1 = lerp(v00, v10, f.x);
    float x2 = lerp(v01, v11, f.x);
    
    return lerp(x1, x2, f.y);
}

float FractalNoise(float2 pos, int numOctaves, float amp, float freq)
{
    float value = 0.0;
    float amplitude = 1.0;
    float frequency = 1.0;
    float maxValue = 0.0;
    
    for (int i = 0; i < numOctaves; i++)
    {
        value += PerlinNoise(pos * frequency) * amplitude;
        maxValue += amplitude;
        amplitude *= amp;
        frequency *= freq;
    }
    
    return value / maxValue;
}

float SampleHeightBilinear(float worldX, float worldZ)
{
    float localX = (worldX - worldBoundsMin.x) / terrainWidth;
    float localZ = (worldZ - worldBoundsMin.z) / terrainHeight;
    
    localX = clamp(localX, 0.0, 1.0);
    localZ = clamp(localZ, 0.0, 1.0);
    
    float gridX = localX * (terrainResolution - 1);
    float gridZ = localZ * (terrainResolution - 1);
    
    int x0 = (int)floor(gridX);
    int z0 = (int)floor(gridZ);
    int x1 = min(x0 + 1, terrainResolution - 1);
    int z1 = min(z0 + 1, terrainResolution - 1);
    
    float fx = gridX - x0;
    float fz = gridZ - z0;
    
    float h00 = heightMap[z0 * terrainResolution + x0];
    float h10 = heightMap[z0 * terrainResolution + x1];
    float h01 = heightMap[z1 * terrainResolution + x0];
    float h11 = heightMap[z1 * terrainResolution + x1];
    
    float h0 = lerp(h00, h10, fx);
    float h1 = lerp(h01, h11, fx);
    
    return lerp(h0, h1, fz);
}

float4x4 CreateTRS(float3 position, float3 rotation, float3 scale)
{
    float cx = cos(rotation.x);
    float sx = sin(rotation.x);
    float cy = cos(rotation.y);
    float sy = sin(rotation.y);
    float cz = cos(rotation.z);
    float sz = sin(rotation.z);
    
    float4x4 mat;
    mat[0][0] = (cy * cz) * scale.x;
    mat[0][1] = (cy * sz) * scale.x;
    mat[0][2] = (-sy) * scale.x;
    mat[0][3] = 0;
    
    mat[1][0] = (sx * sy * cz - cx * sz) * scale.y;
    mat[1][1] = (sx * sy * sz + cx * cz) * scale.y;
    mat[1][2] = (sx * cy) * scale.y;
    mat[1][3] = 0;
    
    mat[2][0] = (cx * sy * cz + sx * sz) * scale.z;
    mat[2][1] = (cx * sy * sz - sx * cz) * scale.z;
    mat[2][2] = (cx * cy) * scale.z;
    mat[2][3] = 0;
    
    mat[3][0] = position.x;
    mat[3][1] = position.y;
    mat[3][2] = position.z;
    mat[3][3] = 1;
    
    return mat;
}

[numthreads(64, 1, 1)]
void PlaceGrass(uint3 id : SV_DispatchThreadID)
{
    uint cellIndex = id.x / bladesPerCell;

    int localX = (int)(cellIndex % gridWidth);
    int localZ = (int)(cellIndex / gridWidth);

    if(localZ < 40 || localX < 20 || localX > 222)
    {
        InstanceData instance;
        instance.color = float4(0, 0, 0, 0);
        instance.trs = CreateTRS(float3(0, -1000, 0), float3(0, 0, 0), float3(0.001, 0.001, 0.001));
        instanceData[id.x] = instance;
        return;
    }
    
    uint bladeIndex = id.x % bladesPerCell;
    int gridX = localX + gridMinX;
    int gridZ = localZ + gridMinZ;
    
    uint bladeSeed = Hash3D((uint)gridX, (uint)gridZ, bladeIndex);
    float2 noisePos = float2(gridX, gridZ) * noiseScale;
    float noiseValue = FractalNoise(noisePos, octaves, persistence, lacunarity);
    
    float densityMultiplier = smoothstep(densityMinThreshold, densityMaxThreshold, noiseValue);
    float finalDensity = density * densityMultiplier;
    
    float densityRoll = HashToFloat(Hash(bladeSeed));
    
    InstanceData instance;
    instance.color = float4(1, 1, 1, 0);
    
    if (densityRoll > finalDensity)
    {
        instance.trs = CreateTRS(float3(0, -1000, 0), float3(0, 0, 0), float3(0.001, 0.001, 0.001));
        instanceData[id.x] = instance;
        return;
    }
    
    float offsetX = HashToFloat(Hash(bladeSeed + 1)) - 0.5;
    float offsetZ = HashToFloat(Hash(bladeSeed + 2)) - 0.5;
    
    float worldX = gridX + offsetX;
    float worldZ = gridZ + offsetZ;
    
    float height = SampleHeightBilinear(worldX, worldZ);
    float3 worldPos = float3(worldX, height, worldZ);
    
    float2 scaleNoisePos = float2(worldX, worldZ) * scaleNoiseScale;
    float scaleNoiseValue = FractalNoise(scaleNoisePos, scaleOctaves, scalePersistence, scaleLacunarity);
    
    float scaleRandom = HashToFloat(Hash(bladeSeed + 3));
    float scaleBase = lerp(scaleMin, scaleMax, scaleRandom);
    float scaleNoiseFactor = lerp(1.0 - scaleNoiseInfluence, 1.0 + scaleNoiseInfluence, scaleNoiseValue);
    
    float scaleXZ = scaleBase * scaleNoiseFactor;
    scaleXZ *= lerp(0.7, 1.0, densityMultiplier);
    
    float scaleY = scaleBase * scaleNoiseFactor * lerp(0.8, 1.2, scaleNoiseValue);
    
    float rotY = HashToFloat(Hash(bladeSeed + 4)) * rotationVariation * 0.01745329;
    
    float3 rotation = float3(0, rotY, 0);
    float3 scaleVec = float3(scaleXZ, scaleY, scaleXZ);
    
    instance.trs = CreateTRS(worldPos, rotation, scaleVec);
    
    float colorVariation = HashToFloat(Hash(bladeSeed + 5)) * 0.2 + 0.9;
    colorVariation *= lerp(0.85, 1.0, noiseValue);
    
    instance.color = float4(colorVariation, colorVariation, colorVariation, 1);
    
    instanceData[id.x] = instance;
}