#pragma kernel PlaceGrass

struct InstanceData
{
    float4x4 trs;
    float4 color;
};

struct Triangle
{
    float3 v0;
    float3 v1;
    float3 v2;
    float3 normal;
    float3 center;
};

RWStructuredBuffer<InstanceData> instanceData;
StructuredBuffer<Triangle> triangles;

int triangleCount;
int instanceCount;
int gridMinX;
int gridMinZ;
int gridWidth;
int gridHeight;
float density;
float scaleMin;
float scaleMax;
float rotationVariation;
float3 worldBoundsMin;
float3 worldBoundsMax;
float cullingDistance;

uint Hash(uint x)
{
    x ^= x >> 16;
    x *= 0x7feb352dU;
    x ^= x >> 15;
    x *= 0x846ca68bU;
    x ^= x >> 16;
    return x;
}

float HashToFloat(uint hash)
{
    return (hash & 0xFFFFFF) / 16777216.0;
}

bool RayTriangleIntersect(float3 origin, float3 dir, Triangle tri, 
                         out float t, out float3 hitPoint)
{
    t = 0.0f;
    hitPoint = float3(0.0f, 0.0f, 0.0f);
    
    const float EPSILON = 1e-8f;
    
    float3 edge1 = tri.v1 - tri.v0;
    float3 edge2 = tri.v2 - tri.v0;
    
    float3 h = cross(dir, edge2);
    float a = dot(edge1, h);
    
    if (a > -EPSILON && a < EPSILON)
        return false;
    
    float f = 1.0f / a;
    float3 s = origin - tri.v0;
    
    float u = f * dot(s, h);
    if (u < 0.0f || u > 1.0f)
        return false;
    
    float3 q = cross(s, edge1);
    float v = f * dot(dir, q);
    if (v < 0.0f || u + v > 1.0f)
        return false;
    
    t = f * dot(edge2, q);
    
    if (t > EPSILON)
    {
        hitPoint = origin + dir * t;
        return true;
    }
    
    return false;
}

float4x4 CreateTRS(float3 position, float3 rotation, float3 scale)
{
    float cx = cos(rotation.x);
    float sx = sin(rotation.x);
    float cy = cos(rotation.y);
    float sy = sin(rotation.y);
    float cz = cos(rotation.z);
    float sz = sin(rotation.z);
    
    float4x4 mat;
    mat[0][0] = (cy * cz) * scale.x;
    mat[0][1] = (cy * sz) * scale.x;
    mat[0][2] = (-sy) * scale.x;
    mat[0][3] = 0;
    
    mat[1][0] = (sx * sy * cz - cx * sz) * scale.y;
    mat[1][1] = (sx * sy * sz + cx * cz) * scale.y;
    mat[1][2] = (sx * cy) * scale.y;
    mat[1][3] = 0;
    
    mat[2][0] = (cx * sy * cz + sx * sz) * scale.z;
    mat[2][1] = (cx * sy * sz - sx * cz) * scale.z;
    mat[2][2] = (cx * cy) * scale.z;
    mat[2][3] = 0;
    
    mat[3][0] = position.x;
    mat[3][1] = position.y;
    mat[3][2] = position.z;
    mat[3][3] = 1;
    
    return mat;
}

[numthreads(64, 1, 1)]
void PlaceGrass(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint)instanceCount) return;
    
    int gridX = (int)(id.x % gridWidth) + gridMinX;
    int gridZ = (int)(id.x / gridWidth) + gridMinZ;
    
    uint seed = Hash((uint)gridX * 73856093U ^ (uint)gridZ * 19349663U);
    float densityRoll = HashToFloat(Hash(seed));
    
    InstanceData instance;
    instance.color = float4(1, 1, 1, 0);
    
    if (densityRoll > density)
    {
        instance.trs = CreateTRS(float3(0, -1000, 0), float3(0, 0, 0), float3(0.001, 0.001, 0.001));
        instanceData[id.x] = instance;
        return;
    }
    
    float offsetX = HashToFloat(Hash(seed + 1)) - 0.5;
    float offsetZ = HashToFloat(Hash(seed + 2)) - 0.5;
    
    float3 worldPos = float3(gridX + offsetX, worldBoundsMax.y + 10, gridZ + offsetZ);
    float3 rayDir = float3(0, -1, 0);
    
    float closestT = 1e10;
    float3 closestHit;
    float3 closestNormal;
    bool foundIntersection = false;
    
    for (int i = 0; i < triangleCount; i++)
    {
        float t;
        float3 hitPoint;
        if (RayTriangleIntersect(worldPos, rayDir, triangles[i], t, hitPoint))
        {
            if (t < closestT)
            {
                closestT = t;
                closestHit = hitPoint;
                closestNormal = triangles[i].normal;
                foundIntersection = true;
            }
        }
    }
    
    if (!foundIntersection)
    {
        instance.trs = CreateTRS(float3(0, -1000, 0), float3(0, 0, 0), float3(0.001, 0.001, 0.001));
        instanceData[id.x] = instance;
        return;
    }
    
    float scale = lerp(scaleMin, scaleMax, HashToFloat(Hash(seed + 3)));
    float rotY = HashToFloat(Hash(seed + 4)) * rotationVariation * 0.01745329;
    
    float3 rotation = float3(0, rotY, 0);
    float3 scaleVec = float3(scale, scale, scale);
    
    instance.trs = CreateTRS(closestHit, rotation, scaleVec);
    
    float colorVariation = HashToFloat(Hash(seed + 5)) * 0.2 + 0.9;
    instance.color = float4(colorVariation, colorVariation, colorVariation, 1);
    
    instanceData[id.x] = instance;
}