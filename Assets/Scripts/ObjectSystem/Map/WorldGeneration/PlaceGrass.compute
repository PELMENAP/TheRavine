#pragma kernel PlaceGrass

struct InstanceData
{
    float4x4 trs;
    float4 color;
};

struct Triangle
{
    float3 v0;
    float3 v1;
    float3 v2;
    float3 normal;
    float3 center;
};

RWStructuredBuffer<InstanceData> instanceData;
StructuredBuffer<Triangle> triangles;

int triangleCount;
int instanceCount;
int gridMinX;
int gridMinZ;
int gridWidth;
int gridHeight;
int bladesPerCell;
float density;
float scaleMin;
float scaleMax;
float rotationVariation;
float3 worldBoundsMin;
float3 worldBoundsMax;
float cullingDistance;
float noiseScale;
float densityMinThreshold;
float densityMaxThreshold;
int octaves;
float persistence;
float lacunarity;

uint Hash(uint input)
{
    uint state = input * 747796405u + 2891336453u;
    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
    return (word >> 22u) ^ word;
}

uint Hash2D(uint x, uint y)
{
    return Hash(x ^ Hash(y));
}

uint Hash3D(uint x, uint y, uint z)
{
    return Hash(x ^ Hash(y ^ Hash(z)));
}

float HashToFloat(uint hash)
{
    return (hash & 0xFFFFFF) / 16777216.0;
}

float PerlinNoise(float2 pos)
{
    int2 i = floor(pos);
    float2 f = frac(pos);
    
    f = f * f * (3.0 - 2.0 * f);
    
    uint hash00 = Hash2D((uint)i.x, (uint)i.y);
    uint hash10 = Hash2D((uint)i.x + 1, (uint)i.y);
    uint hash01 = Hash2D((uint)i.x, (uint)i.y + 1);
    uint hash11 = Hash2D((uint)i.x + 1, (uint)i.y + 1);
    
    float v00 = HashToFloat(hash00);
    float v10 = HashToFloat(hash10);
    float v01 = HashToFloat(hash01);
    float v11 = HashToFloat(hash11);
    
    float x1 = lerp(v00, v10, f.x);
    float x2 = lerp(v01, v11, f.x);
    
    return lerp(x1, x2, f.y);
}

float FractalNoise(float2 pos)
{
    float value = 0.0;
    float amplitude = 1.0;
    float frequency = 1.0;
    float maxValue = 0.0;
    
    for (int i = 0; i < octaves; i++)
    {
        value += PerlinNoise(pos * frequency) * amplitude;
        maxValue += amplitude;
        amplitude *= persistence;
        frequency *= lacunarity;
    }
    
    return value / maxValue;
}

bool RayTriangleIntersect(float3 origin, float3 dir, Triangle tri, 
                         out float t, out float3 hitPoint)
{
    t = 0.0f;
    hitPoint = float3(0.0f, 0.0f, 0.0f);
    
    const float EPSILON = 1e-8f;
    
    float3 edge1 = tri.v1 - tri.v0;
    float3 edge2 = tri.v2 - tri.v0;
    
    float3 h = cross(dir, edge2);
    float a = dot(edge1, h);
    
    if (a > -EPSILON && a < EPSILON)
        return false;
    
    float f = 1.0f / a;
    float3 s = origin - tri.v0;
    
    float u = f * dot(s, h);
    if (u < 0.0f || u > 1.0f)
        return false;
    
    float3 q = cross(s, edge1);
    float v = f * dot(dir, q);
    if (v < 0.0f || u + v > 1.0f)
        return false;
    
    t = f * dot(edge2, q);
    
    if (t > EPSILON)
    {
        hitPoint = origin + dir * t;
        return true;
    }
    
    return false;
}

float4x4 CreateTRS(float3 position, float3 rotation, float3 scale)
{
    float cx = cos(rotation.x);
    float sx = sin(rotation.x);
    float cy = cos(rotation.y);
    float sy = sin(rotation.y);
    float cz = cos(rotation.z);
    float sz = sin(rotation.z);
    
    float4x4 mat;
    mat[0][0] = (cy * cz) * scale.x;
    mat[0][1] = (cy * sz) * scale.x;
    mat[0][2] = (-sy) * scale.x;
    mat[0][3] = 0;
    
    mat[1][0] = (sx * sy * cz - cx * sz) * scale.y;
    mat[1][1] = (sx * sy * sz + cx * cz) * scale.y;
    mat[1][2] = (sx * cy) * scale.y;
    mat[1][3] = 0;
    
    mat[2][0] = (cx * sy * cz + sx * sz) * scale.z;
    mat[2][1] = (cx * sy * sz - sx * cz) * scale.z;
    mat[2][2] = (cx * cy) * scale.z;
    mat[2][3] = 0;
    
    mat[3][0] = position.x;
    mat[3][1] = position.y;
    mat[3][2] = position.z;
    mat[3][3] = 1;
    
    return mat;
}

[numthreads(64, 1, 1)]
void PlaceGrass(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint)instanceCount) return;
    
    uint totalCells = gridWidth * gridHeight;
    uint cellIndex = id.x / bladesPerCell;
    uint bladeIndex = id.x % bladesPerCell;
    
    int gridX = (int)(cellIndex % gridWidth) + gridMinX;
    int gridZ = (int)(cellIndex / gridWidth) + gridMinZ;
    
    uint cellSeed = Hash2D((uint)gridX, (uint)gridZ);
    uint bladeSeed = Hash3D((uint)gridX, (uint)gridZ, bladeIndex);
    
    float2 noisePos = float2(gridX, gridZ) * noiseScale;
    float noiseValue = FractalNoise(noisePos);
    
    float densityMultiplier = smoothstep(densityMinThreshold, densityMaxThreshold, noiseValue);
    float finalDensity = density * densityMultiplier;
    
    float densityRoll = HashToFloat(Hash(bladeSeed));
    
    InstanceData instance;
    instance.color = float4(1, 1, 1, 0);
    
    if (densityRoll > finalDensity)
    {
        instance.trs = CreateTRS(float3(0, -1000, 0), float3(0, 0, 0), float3(0.001, 0.001, 0.001));
        instanceData[id.x] = instance;
        return;
    }
    
    float offsetX = HashToFloat(Hash(bladeSeed + 1)) - 0.5;
    float offsetZ = HashToFloat(Hash(bladeSeed + 2)) - 0.5;
    
    float3 worldPos = float3(gridX + offsetX, worldBoundsMax.y + 10, gridZ + offsetZ);
    float3 rayDir = float3(0, -1, 0);
    
    float closestT = 1e10;
    float3 closestHit;
    float3 closestNormal;
    bool foundIntersection = false;
    
    for (int i = 0; i < triangleCount; i++)
    {
        float t;
        float3 hitPoint;
        if (RayTriangleIntersect(worldPos, rayDir, triangles[i], t, hitPoint))
        {
            if (t < closestT)
            {
                closestT = t;
                closestHit = hitPoint;
                closestNormal = triangles[i].normal;
                foundIntersection = true;
            }
        }
    }
    
    if (!foundIntersection)
    {
        instance.trs = CreateTRS(float3(0, -1000, 0), float3(0, 0, 0), float3(0.001, 0.001, 0.001));
        instanceData[id.x] = instance;
        return;
    }
    
    float scale = lerp(scaleMin, scaleMax, HashToFloat(Hash(bladeSeed + 3)));
    scale *= lerp(0.7, 1.0, densityMultiplier);
    
    float rotY = HashToFloat(Hash(bladeSeed + 4)) * rotationVariation * 0.01745329;
    
    float3 rotation = float3(0, rotY, 0);
    float3 scaleVec = float3(scale, scale, scale);
    
    instance.trs = CreateTRS(closestHit, rotation, scaleVec);
    
    float colorVariation = HashToFloat(Hash(bladeSeed + 5)) * 0.2 + 0.9;
    colorVariation *= lerp(0.85, 1.0, noiseValue);
    
    instance.color = float4(colorVariation, colorVariation, colorVariation, 1);
    
    instanceData[id.x] = instance;
}