#pragma kernel PlaceGrass
#pragma kernel CullGrass

struct InstanceData
{
    float4x4 trs;
    float4 color;
};

struct VertexData
{
    float3 position;
};

RWStructuredBuffer<InstanceData> instanceData;
AppendStructuredBuffer<InstanceData> culledInstanceData;
StructuredBuffer<VertexData> vertices;
StructuredBuffer<int> indices;

int instanceCount;
int triangleCount;
float3 scaleMin;
float3 scaleMax;
bool randomYRotation;
float maxYRotation;
float2 xzBoundsMin;
float2 xzBoundsMax;
float gridCellSize;

bool useDensityNoise;
float noiseScale;
float densityThreshold;
int noiseOctaves;
float noiseLacunarity;
float noisePersistence;

bool useHeightColorVariation;
float minHeight;
float maxHeight;
bool useRandomColorTint;
float colorVariation;

int gradientResolution;
float4 heightGradient[64];

bool useDistanceBasedDensity;
float2 distanceCenter;
float maxDistanceForDensity;
int densityCurveResolution;
float densityCurve[64];

bool useHeightConstraints;
float minGenerationHeight;
float maxGenerationHeight;

float4 plane0;
float4 plane1;
float4 plane2;
float4 plane3;
float4 plane4;
float4 plane5;
float cullingMargin;

uint PCGHash(uint input)
{
    uint state = input * 747796405u + 2891336453u;
    uint word  = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
    return (word >> 22u) ^ word;
}

float Random(uint seed)
{
    return PCGHash(seed) * (1.0 / 4294967296.0);
}

uint WorldPosToSeed(float2 worldPos, float cellSize)
{
    int2 gridCoord = int2(floor(worldPos / cellSize));
    return (uint)gridCoord.x * 73856093u + (uint)gridCoord.y * 19349663u;
}

float Hash2D(float2 p)
{
    float3 p3 = frac(float3(p.xyx) * 0.1031);
    p3 += dot(p3, p3.yzx + 33.33);
    return frac((p3.x + p3.y) * p3.z);
}

float PerlinNoise(float2 p)
{
    float2 i = floor(p);
    float2 f = frac(p);
    
    float2 u = f * f * (3.0 - 2.0 * f);
    
    float a = Hash2D(i);
    float b = Hash2D(i + float2(1.0, 0.0));
    float c = Hash2D(i + float2(0.0, 1.0));
    float d = Hash2D(i + float2(1.0, 1.0));
    
    return lerp(lerp(a, b, u.x), lerp(c, d, u.x), u.y);
}

float FractalNoise(float2 p, int octaves, float lacunarity, float persistence)
{
    float value = 0.0;
    float amplitude = 1.0;
    float frequency = 1.0;
    float maxValue = 0.0;
    
    for (int i = 0; i < octaves; i++)
    {
        value += PerlinNoise(p * frequency) * amplitude;
        maxValue += amplitude;
        amplitude *= persistence;
        frequency *= lacunarity;
    }
    
    return value / maxValue;
}

float4 SampleGradient(float t)
{
    t = saturate(t);
    float indexFloat = t * (gradientResolution - 1);
    int index0 = floor(indexFloat);
    int index1 = min(index0 + 1, gradientResolution - 1);
    float frac = indexFloat - index0;
    
    return lerp(heightGradient[index0], heightGradient[index1], frac);
}

float SampleDensityCurve(float t)
{
    t = saturate(t);
    float indexFloat = t * (densityCurveResolution - 1);
    int index0 = floor(indexFloat);
    int index1 = min(index0 + 1, densityCurveResolution - 1);
    float frac = indexFloat - index0;
    
    return lerp(densityCurve[index0], densityCurve[index1], frac);
}

bool RayTriangleIntersect(float3 rayOrigin, float3 rayDir, float3 v0, float3 v1, float3 v2, out float t)
{
    float3 edge1 = v1 - v0;
    float3 edge2 = v2 - v0;
    float3 h = cross(rayDir, edge2);
    float a = dot(edge1, h);
    
    if (abs(a) < 0.0001)
    {
        t = 0;
        return false;
    }
    
    float f = 1.0 / a;
    float3 s = rayOrigin - v0;
    float u = f * dot(s, h);
    
    if (u < 0.0 || u > 1.0)
    {
        t = 0;
        return false;
    }
    
    float3 q = cross(s, edge1);
    float v = f * dot(rayDir, q);
    
    if (v < 0.0 || u + v > 1.0)
    {
        t = 0;
        return false;
    }
    
    t = f * dot(edge2, q);
    return t > 0.0001;
}

bool FindMeshIntersection(float2 xzPos, out float3 hitPoint)
{
    float3 rayOrigin = float3(xzPos.x, 10000.0, xzPos.y);
    float3 rayDir = float3(0, -1, 0);
    
    float closestT = 1000000.0;
    bool hit = false;
    
    for (int i = 0; i < triangleCount; i++)
    {
        int i0 = indices[i * 3];
        int i1 = indices[i * 3 + 1];
        int i2 = indices[i * 3 + 2];
        
        float3 v0 = vertices[i0].position;
        float3 v1 = vertices[i1].position;
        float3 v2 = vertices[i2].position;
        
        float t;
        if (RayTriangleIntersect(rayOrigin, rayDir, v0, v1, v2, t))
        {
            if (t < closestT)
            {
                closestT = t;
                hit = true;
            }
        }
    }
    
    hitPoint = rayOrigin + rayDir * closestT;
    return hit;
}

float4 QuaternionAxisAngle(float3 axis, float angle)
{
    float halfAngle = angle * 0.5;
    float s = sin(halfAngle);
    return float4(axis * s, cos(halfAngle));
}

float3x3 QuaternionToMatrix(float4 q)
{
    float x = q.x, y = q.y, z = q.z, w = q.w;
    float x2 = x + x, y2 = y + y, z2 = z + z;
    float xx = x * x2, xy = x * y2, xz = x * z2;
    float yy = y * y2, yz = y * z2, zz = z * z2;
    float wx = w * x2, wy = w * y2, wz = w * z2;
    
    float3x3 m;
    m[0][0] = 1.0 - (yy + zz);
    m[0][1] = xy + wz;
    m[0][2] = xz - wy;
    m[1][0] = xy - wz;
    m[1][1] = 1.0 - (xx + zz);
    m[1][2] = yz + wx;
    m[2][0] = xz + wy;
    m[2][1] = yz - wx;
    m[2][2] = 1.0 - (xx + yy);
    
    return m;
}

float4x4 TRS(float3 position, float4 rotation, float3 scale)
{
    float3x3 rotMatrix = QuaternionToMatrix(rotation);
    
    float4x4 mat;
    mat[0] = float4(rotMatrix[0] * scale.x, 0);
    mat[1] = float4(rotMatrix[1] * scale.y, 0);
    mat[2] = float4(rotMatrix[2] * scale.z, 0);
    mat[3] = float4(position, 1);
    
    return mat;
}

[numthreads(64, 1, 1)]
void PlaceGrass(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint)instanceCount)
        return;
    
    float2 boundsSize = xzBoundsMax - xzBoundsMin;
    float2 normalizedPos = float2(
        (id.x % (uint)sqrt((float)instanceCount)) / sqrt((float)instanceCount),
        (id.x / (uint)sqrt((float)instanceCount)) / sqrt((float)instanceCount)
    );
    
    float2 baseXZ = xzBoundsMin + boundsSize * normalizedPos;
    uint baseSeed = WorldPosToSeed(baseXZ, gridCellSize);
    
    float2 offset = float2(
        (Random(baseSeed) - 0.5) * gridCellSize,
        (Random(baseSeed + 1) - 0.5) * gridCellSize
    );
    
    float2 xzPos = baseXZ + offset;
    xzPos = clamp(xzPos, xzBoundsMin, xzBoundsMax);
    
    bool shouldPlace = true;
    
    if (useDensityNoise)
    {
        float noiseValue = FractalNoise(xzPos * noiseScale, noiseOctaves, noiseLacunarity, noisePersistence);
        shouldPlace = noiseValue > densityThreshold;
    }
    
    if (useDistanceBasedDensity && shouldPlace)
    {
        float dist = distance(xzPos, distanceCenter);
        float normalizedDist = saturate(dist / maxDistanceForDensity);
        float densityMultiplier = SampleDensityCurve(normalizedDist);
        
        uint distSeed = WorldPosToSeed(xzPos, gridCellSize) + 999;
        shouldPlace = Random(distSeed) < densityMultiplier;
    }
    
    if (!shouldPlace)
    {
        instanceData[id.x].trs = TRS(float3(0, -10000, 0), float4(0, 0, 0, 1), float3(0, 0, 0));
        instanceData[id.x].color = float4(0, 0, 0, 0);
        return;
    }
    
    uint worldSeed = WorldPosToSeed(xzPos, gridCellSize);
    
    float3 position;
    if (!FindMeshIntersection(xzPos, position))
    {
        position = float3(xzPos.x, 0, xzPos.y);
    }

    if (useHeightConstraints)
    {
        if (position.y < minGenerationHeight || position.y > maxGenerationHeight)
        {
            instanceData[id.x].trs = TRS(float3(0, -10000, 0), float4(0, 0, 0, 1), float3(0, 0, 0));
            instanceData[id.x].color = float4(0, 0, 0, 0);
            return;
        }
    }
    
    float3 scale = lerp(scaleMin, scaleMax, float3(
        Random(worldSeed + 2),
        Random(worldSeed + 3),
        Random(worldSeed + 4)
    ));
    
    float4 rotation = float4(0, 0, 0, 1);
    
    if (randomYRotation)
    {
        float yAngle = (Random(worldSeed + 5) * 2.0 - 1.0) * maxYRotation * 0.0174533;
        rotation = QuaternionAxisAngle(float3(0, 1, 0), yAngle);
    }
    
    instanceData[id.x].trs = TRS(position, rotation, scale);
    
    float4 color = float4(1, 1, 1, 1);
    
    if (useHeightColorVariation)
    {
        float heightNormalized = saturate((position.y - minHeight) / (maxHeight - minHeight));
        color = SampleGradient(heightNormalized);
    }
    
    if (useRandomColorTint)
    {
        float3 tint = float3(
            1.0 + (Random(worldSeed + 6) * 2.0 - 1.0) * colorVariation,
            1.0 + (Random(worldSeed + 7) * 2.0 - 1.0) * colorVariation,
            1.0 + (Random(worldSeed + 8) * 2.0 - 1.0) * colorVariation
        );
        color.rgb *= tint;
    }
    
    instanceData[id.x].color = color;
}

bool SphereInPlane(float4 plane, float3 center, float radius)
{
    return dot(plane.xyz, center) + plane.w + radius >= 0.0;
}

float3 GetBoundsCenter(float4x4 trs)
{
    return float3(trs[3][0], trs[3][1], trs[3][2]);
}

float GetBoundsRadius(float4x4 trs)
{
    float scaleX = length(float3(trs[0][0], trs[0][1], trs[0][2]));
    float scaleY = length(float3(trs[1][0], trs[1][1], trs[1][2]));
    float scaleZ = length(float3(trs[2][0], trs[2][1], trs[2][2]));
    return max(scaleX, max(scaleY, scaleZ)) * 0.5;
}

[numthreads(64, 1, 1)]
void CullGrass(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint)instanceCount)
        return;
    
    InstanceData instance = instanceData[id.x];
    
    if (instance.color.a < 0.01)
        return;
    
    float3 center = GetBoundsCenter(instance.trs);
    float radius = GetBoundsRadius(instance.trs);
    
    bool visible = SphereInPlane(plane0, center, radius + cullingMargin) &&
                   SphereInPlane(plane1, center, radius + cullingMargin) &&
                   SphereInPlane(plane2, center, radius + cullingMargin) &&
                   SphereInPlane(plane3, center, radius + cullingMargin) &&
                   SphereInPlane(plane4, center, radius + cullingMargin) &&
                   SphereInPlane(plane5, center, radius + cullingMargin);
    
    if (visible)
    {
        culledInstanceData.Append(instance);
    }
}